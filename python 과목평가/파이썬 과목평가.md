# 파이썬 과목평가

## 01_python_intro

* ##### 시퀀스 자료형의 특징과 활용방법
  
  * `시퀸스`는 데이터가 순서대로 나열된 형식을 나타냅니다. (정렬되었다는 뜻이 아님) 
    1. 리스트(`list`) : `[]`, `list()`로 표현 (mutable)
    2. 튜플(`tuple`) : `()`로 표현, 수정 불가능(불변, immutable)
    3. 레인지(`range`) : 숫자의 시퀴스를 나타내기 위해 사용 (범위 및 스텝 지정 `range(start, stop[, step])`)
       - step 인자가 생략되면 기본값 `1`이 사용된다.
       - start 인자가 생략되면 기본값 `0`이 사용된다.
       - step 이 `0`이면 `ValueError`를 일으킨다.
    4. 문자열(`string`)
    5. 바이너리(`binary`)
  
* ##### 연산자

  * 산술연산자 (`+`, `-`, `*`, `/`, `//`, `%`, `**`)
    
    * 나눗셈(`/`)은 항상 float를 돌려준다.
    
  * 비교연산자 (`<`, `<=`, `>`, `>=`, `==`, `!=`, `is`:객체 아이덴티티, `is not`:부정된 객체 아이덴티티)

  * 논리연산자 (`a and b`, `a or b`, `not a`)
    * `and`는 a가 거짓이면 a를 리턴하고, 참이면 b를 리턴한다.
    * `or`은 a가 참이면 a를 리턴하고, 거짓이면 b를 리턴한다.
    
  * 복합연산자 (`+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `**=`)

  * 기타연산자
    1. Concatenation : 숫자가 아닌 자료형은 `+` 연산자를 통해 합칠 수 있습니다.
    2. Containment Test : `in` 연산자를 통해 요소가 속해있는지 여부를 확인할 수 있습니다.
    3. Identity : `is` 연산자를 통해 동일한 object인지 확인할 수 있습니다. (257 이후 id는 다름)
    4. Indexing/Slicing : `[]`를 통한 값을 접근하고, `[:]`을 통해 리스트를 슬라이싱할 수 있습니다.
    
  * 연산자 우선순위

    ```
    1. `()`을 통한 grouping
    2. Slicing
    3. Indexing
    4. 제곱연산자 `**`
    5. 단항연산자 `+`, `-` (음수/양수 부호)
    6. 산술연산자 `*`, `/`, `%`
    7. 산술연산자 `+`, `-`
    8. 비교연산자, `in`, `is`
    9. `not`
    10. `and`
    11. `or`
    ```

## 02_control_of_flow

* ##### 기본적인 반복문과 조건문

  * 조건문 (`if <조건식>:`)

    * `if`, `else`

    * 복수조건문 `elif <조건문>:`

    * 조건 표현식

      * ```python
        true_value if <조건식> else false_value
        ```

  * 반복문

    * `while`문

      * 조건식이 참(True)인 경우 반복적으로 코드를 실행.
      * 종료조건을 반드시 설정

    * `for` 문

      * 정해진 범위 내 시퀀스(문자열, 튜플, 리스트 같은)나 다른 반복가능한 객체(iterable)의 요소들을 순차적으로 코드를 실행

      * Index와 함께 `for`문 활용

        * `enumerate()`를 활용하면, 추가적인 변수를 활용할 수 있습니다.

      * dictionary에서 `for` 활용하는 4가지 방법

        ```python
        # 0. dictionary (key 반복)
        for key in dict:
            print(key)
            
        # 1. key 반복
        for key in dict.keys():
            print(key)
            
        # 2. value 반복    
        for val in dict.values():
            print(val)
        
        # 3. key와 value 반복
        for key, val in dict.items():
            print(key, val)
        ```

  * `break` 문은 반복문을 종료하는 표현입니다.

  * `continue`문은 continue 이후의 코드를 수행하지 않고 다음 요소를 선택해 반복을 계속 수행합니다.

  * `else` 문은 끝까지 반복문을 시행한 이후에 실행된다.

    *  `break` 문으로 종료할 때는 실행되지 않는다.

  * `pass` 문은 아무것도 하지 않습니다. 문법적으로 문장이 필요하지만, 프로그램이 특별히 할 일이 없을 때 자리를 채우는 용도로 사용할 수 있습니다.

## 03_function

- ##### 함수 인자의 종류

  - 위치 인자 : 함수는 기본적으로 인자를 위치로 판단

    - 호출시 인자가 없으면 기본 인자 값이 활용.

  - 키워드 인자 : 직접 변수의 이름으로 특정 인자를 전달할 수 있습니다.

    ```python
    # 키워드 인자 예시
    def greeting(age, name='Song'):
        print(f'{name}은 {age}살 입니다.')
    greeting(name='준기',age=24)
    ```

  - 가변 인자 리스트 : 개수가 정해지지 않은 임의의 인자를 받기 위해서 활용

    - `tuple` 형태로 처리가 되며, 매개변수에 `*`로 표현합니다.

      ```python
      def func(a, b, *args):
      *args : 임의의 개수의 위치인자를 받음을 의미
      보통, 이 가변인자 리스트는 형식 인자 목록의 마지막에 옵니다.
      ```

  - 정의되지 않은 키워드 인자 : `dict` 형태로 처리가 되며, `**`로 표현

    - 주로 `kwagrs`라는 이름을 사용하며, `**kwargs`를 통해 인자를 받아 처리

      ```python
      def func(**kwargs):
      **kwargs : 임의의 개수의 키워드 인자를 받음을 의미
      ```

  - 인자 리스트 언패킹

    - 패킹(packing) : 여러 개의 값을 하나의 컬렉션으로 묶어 변수에 대입하는 것

      ```python
      collection = 1, 2, 3
      ```

    - 언패킹(unpacking) : 컬렉션 속의 요소들을 여러 개의 변수에 나누어 대입하는 것

      ```python
      a, b, c = collection
      ```

  - ##### 함수의 리턴

    - 함수는 동작후에 `return`을 통해 결과값을 전달 할 수도 있다.

      (`return` 값이 없으면, `None`을 반환한다.)

    - 한 개의 객체만 반환

  - ##### 스코프

    - 이름공간

    - `LEGB Rule` : 변수에서 값을 찾을 때 아래와 같은 순서대로 이름을 찾아나갑니다.

      ```
      - Local scope: 정의된 함수
      - Enclosed scope: 상위 함수
      - Global scope: 함수 밖의 변수 혹은 import된 모듈
      - Built-in scope: 파이썬안에 내장되어 있는 함수 또는 속성
      ```

## 04_data_structure

- ##### map, zip, filter

- ##### Comprehension

  - List Comprehension은 리스트안에 식, for 문을 지정합니다. 여러 줄의 코드를 한 줄로 줄일 수 있습니다.

    ```python
    [식 for 변수 in iterable]
    list(식 for 변수 in iterable)
    
    # Comprehension + 조건문
    [식 for 변수 in iterable if 조건식]
    [식 if 조건식 else 식 for 변수 in iterable]
    
    # elif 는 다음과 같이 사용해야 합니다. (if else 열거)
    [식 if 조건식 else 식 if 조건식 else 식 if ... else ... for 변수 in iterable]
    ```

- ##### 딕셔너리 메소드

  - 추가 및 삭제 `.pop(key[, default])`

    - key가 딕셔너리에 있으면 제거하고 그 값을 돌려줍니다. 그렇지 않으면 default를 반환합니다.
    - default가 없는 상태에서 딕셔너리에 없으면 KeyError가 발생합니다.

  - `.update()`

    - 값을 제공하는 key, value로 덮어씁니다.

      ```python
      my_dict = {'apple': '사과', 'banana': '바나나', 'melon': '멜론'}
      my_dict.update(사과='사과아', apple='apple')
      # my_dict['사과'] = '사과아'
      
      {'apple': 'apple', 'banana': '바나나', 'melon': '멜론', '사과': '사과아'}
      ```

  - `.get(key[, defailt])`

    - key를 통해 value를 가져옵니다.

    - 절대로 KeyError가 발생하지 않습니다. default는 기본적으로 None입니다

      ```py
      my_dict = {'apple': '사과', 'banana': '바나나', 'melon': '멜론'}
      my_dict.get('pineapple','파인애플')
      
      '파인애플'
      ```

      

- ##### copy

  - 기본형(primitive)과 참조형(reference)은 서로 다르게 동작

  - 다른 얕은 복사 (shallow copy)

    ```python
    a = [1,2,3]
    b = list(a)
    b[0] = 5
    print(a)
    print(b)
    
    [1, 2, 3]
    [5, 2, 3]
    ```

  - 깊은 복사 (deep copy) :  2차원 배열 이상 복사

    ```python
    import copy
    
    a = [1,2,[1,2]]
    b = copy.deepcopy(a)
    b[2][0] = 5
    print(a)
    print(b)
    
    [1, 2, [1, 2]]
    [1, 2, [5, 2]]
    ```

    

